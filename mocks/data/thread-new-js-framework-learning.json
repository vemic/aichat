{
  "id": "thread-new-js-framework-learning",
  "title": "Next.js学習ロードマップと実践的スキル習得",
  "messages": [
    {
      "id": "msg-jslearn-1",
      "role": "user",
      "content": "React開発経験3年。Next.js（SSR, SSG, API Routes等）学習し実践的アプリ（認証機能付きブログシステム等）構築スキル習得目標。効率的学習ロードマップと推奨教材（公式ドキュメント以外のチュートリアル/書籍/オンラインコース等）を教えてほしい。（社内技術研修プログラム TRN-PRG-005 にNext.jsコースがあればそれも）",
      "timestamp": 1716195600000
    },
    {
      "id": "msg-jslearn-2",
      "role": "assistant",
      "content": "React経験者向けNext.js学習ロードマップと推奨教材です。（出典：Next.js公式ドキュメント、一般的なWeb開発学習リソース、及び社内技術研修ポータル情報）\n\n**学習ロードマップ**:\n1.  **基礎固め (1-2週)**: Next.js公式チュートリアル([Next.js Learn](https://nextjs.org/learn))。主要概念(SSR,SSG,ISR,CSR)理解。\n2.  **小規模プロジェクト実践 (2-4週)**: 簡単なブログ/ポートフォリオサイト作成。SSG、API Routes、動的ルーティング、スタイリング実践。\n3.  **中級トピック学習と機能拡張 (4-8週)**: 認証(NextAuth.js - 社内推奨: Keycloak連携アダプタ)、状態管理(Context,Zustand等)、DB連携(Prisma,Supabase等 - 社内標準DB利用検討)、フォーム処理(React Hook Form等)、テスト(Jest,RTL,Cypress等)、デプロイ(Vercel等 - 社内PaaS環境利用ガイド参照)。\n4.  **応用・発展 (継続的)**: パフォーマンス最適化(`next/image`,`next/font`等)、TypeScript導入、GraphQL連携、i18n、Monorepo。\n\n**おすすめ教材 (公式以外)**:\n* **オンラインコース**: Maximilian Schwarzmüller (Academind) - \"Next.js 14 & React - The Complete Guide\" (Udemy)。Vercel YouTube Channel。Fireship.io YouTube Channel。Lee Robinsonブログ/YouTube。\n   * **社内研修**: 現在、技術研修プログラム TRN-PRG-005 にNext.js専門コースはありませんが、フロントエンド技術勉強会（月1開催、Teams #frontend-study）で有志による発表や情報交換があります。\n* **書籍**: 出版年新しい「実践Next.js」等。Webリソースと併用推奨。\n* **チュートリアル/ブログ**: Smashing Magazine, dev.to, freeCodeCamp News, LogRocket Blog。「Next.js tutorial blog」等で検索。GitHubのOSSプロジェクト。\n\n**学習ポイント**: 手を動かす。公式ドキュメント常に参照。コミュニティ活用。社内勉強会参加。",
      "timestamp": 1716195960000
    },
    {
      "id": "msg-jslearn-3",
      "role": "user",
      "content": "Next.js API RoutesでCRUD API（データはインメモリ配列、Todoアイテム：id, text, completed）実装サンプルコードと、フロントエンドReactコンポーネントから`fetch`で呼び出しTodoリスト表示・追加・削除する具体的手順を教えてほしい。状態管理はReact `useState`で。（社内API設計標準 API-STD-001 があれば考慮）",
      "timestamp": 1716196080000
    },
    {
      "id": "msg-jslearn-4",
      "role": "assistant",
      "content": "Next.js API Routes を使ったインメモリCRUD APIと、Reactコンポーネントからの利用例を説明します。（出典：Next.js公式ドキュメント、一般的なREST API設計原則。社内API設計標準 API-STD-001「エンドポイント設計規約」も参考にしてください）\n\n**1. API Routesの実装 (Todo API)**\n\n`pages/api/todos/index.js` (一覧取得 POST /todos, 新規作成 GET /todos) と `pages/api/todos/[id].js` (個別取得 GET /todos/{id}, 更新 PUT /todos/{id}, 削除 DELETE /todos/{id}) を作成します。\n(API-STD-001 Sec.2.1「リソース指向URL」及び Sec.2.2「HTTPメソッド」準拠)\n\n**`pages/api/todos/index.js`**:\n```javascript\n// ダミーデータ (サーバーサイドで保持 - 実際はDB等推奨)\nif (!global.todos) {\n  global.todos = [\n    { id: 1, text: 'Next.jsの学習', completed: false },\n    { id: 2, text: 'API Routesの実装', completed: true },\n  ];\n  global.nextId = 3;\n}\n\nexport default function handler(req, res) {\n  // 社内API標準に基づき、リクエストヘッダに X-Request-ID があるか等チェック推奨 (API-STD-001 Sec.3.1)\n  if (req.method === 'GET') {\n    res.status(200).json(global.todos);\n  } else if (req.method === 'POST') {\n    const { text } = req.body;\n    if (!text || typeof text !== 'string' || text.trim() === '') { // バリデーション (API-STD-001 Sec.4.1)\n      return res.status(400).json({ message: 'Text is required and must be a non-empty string' });\n    }\n    const newTodo = {\n      id: global.nextId++,\n      text: text.trim(),\n      completed: false,\n    };\n    global.todos.push(newTodo);\n    res.status(201).json(newTodo); // 作成成功時は201 Created (API-STD-001 Sec.2.3)\n  } else {\n    res.setHeader('Allow', ['GET', 'POST']);\n    res.status(405).end(`Method ${req.method} Not Allowed`);\n  }\n}\n```\n\n**`pages/api/todos/[id].js`**:\n```javascript\n// index.js と同様に global.todos を参照\nif (!global.todos) { /* 初期化処理 (上記参照) */ }\n\nexport default function handler(req, res) {\n  const { id } = req.query;\n  const todoId = parseInt(id);\n\n  if (isNaN(todoId)) { // ID形式バリデーション (API-STD-001 Sec.4.1)\n    return res.status(400).json({ message: 'Invalid ID format' });\n  }\n\n  const todoIndex = global.todos.findIndex(t => t.id === todoId);\n\n  if (todoIndex === -1 && req.method !== 'PUT') { // PUT以外で対象がない場合は404\n     // PUTの場合はUpsertとして扱うことも考えられるが、今回は対象なしなら404\n    return res.status(404).json({ message: 'Todo not found' });\n  }\n\n  if (req.method === 'GET') {\n    res.status(200).json(global.todos[todoIndex]);\n  } else if (req.method === 'PUT') {\n    if (todoIndex === -1) return res.status(404).json({ message: 'Todo not found for update' });\n    const { text, completed } = req.body;\n    // バリデーション (API-STD-001 Sec.4.1)\n    if (text !== undefined && (typeof text !== 'string' || text.trim() === '')) {\n        return res.status(400).json({ message: 'Text must be a non-empty string if provided' });\n    }\n    if (completed !== undefined && typeof completed !== 'boolean'){\n        return res.status(400).json({ message: 'Completed must be a boolean if provided'});\n    }\n    const updatedTodo = { \n        ...global.todos[todoIndex], \n        text: text !== undefined ? text.trim() : global.todos[todoIndex].text, \n        completed: completed !== undefined ? completed : global.todos[todoIndex].completed \n    };\n    global.todos[todoIndex] = updatedTodo;\n    res.status(200).json(updatedTodo);\n  } else if (req.method === 'DELETE') {\n    if (todoIndex === -1) return res.status(404).json({ message: 'Todo not found for delete' });\n    global.todos.splice(todoIndex, 1);\n    res.status(204).end(); // No content (API-STD-001 Sec.2.3)\n  } else {\n    res.setHeader('Allow', ['GET', 'PUT', 'DELETE']);\n    res.status(405).end(`Method ${req.method} Not Allowed`);\n  }\n}\n```\n*注意*: 上記のインメモリ状態管理はデモ用です。実際はDB等が必要です。\n\n**2. フロントエンドReactコンポーネントの実装**\n\n`pages/index.js` に以下のように実装します。\n\n```jsx\nimport { useState, useEffect } from 'react';\n\nexport default function HomePage() {\n  const [todos, setTodos] = useState([]);\n  const [inputText, setInputText] = useState('');\n  const [error, setError] = useState(null);\n\n  const API_BASE_URL = '/api/todos'; // APIエンドポイントベースURL\n\n  const fetchTodos = async () => {\n    setError(null);\n    try {\n      const res = await fetch(API_BASE_URL);\n      if (!res.ok) throw new Error(`Failed to fetch todos: ${res.statusText}`);\n      const data = await res.json();\n      setTodos(data);\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n    }\n  };\n\n  useEffect(() => {\n    fetchTodos();\n  }, []);\n\n  const addTodo = async (e) => {\n    e.preventDefault();\n    if (!inputText.trim()) return;\n    setError(null);\n    try {\n      const res = await fetch(API_BASE_URL, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' }, // (API-STD-001 Sec.3.2「コンテントネゴシエーション」)\n        body: JSON.stringify({ text: inputText }),\n      });\n      if (!res.ok) throw new Error(`Failed to add todo: ${res.statusText}`);\n      const newTodo = await res.json();\n      setTodos([...todos, newTodo]);\n      setInputText('');\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n    }\n  };\n\n  const deleteTodo = async (id) => {\n    setError(null);\n    try {\n      const res = await fetch(`${API_BASE_URL}/${id}`, {\n        method: 'DELETE',\n      });\n      if (!res.ok && res.status !== 204) throw new Error(`Failed to delete todo: ${res.statusText}`);\n      setTodos(todos.filter(todo => todo.id !== id));\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n    }\n  };\n\n  const toggleComplete = async (id) => {\n    const todo = todos.find(t => t.id === id);\n    if (!todo) return;\n    setError(null);\n    try {\n      const res = await fetch(`${API_BASE_URL}/${id}`, {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ completed: !todo.completed }), // textは変更しない例\n      });\n      if (!res.ok) throw new Error(`Failed to update todo: ${res.statusText}`);\n      const updatedTodo = await res.json();\n      setTodos(todos.map(t => (t.id === id ? updatedTodo : t)));\n    } catch (err) {\n      console.error(err);\n      setError(err.message);\n    }\n  };\n\n  return (\n    <div style={{ maxWidth: '500px', margin: 'auto', padding: '20px' }}>\n      <h1>Todo App (Next.js API Routes)</h1>\n      {error && <p style={{color: 'red'}}>Error: {error}</p>}\n      <form onSubmit={addTodo} style={{ display: 'flex', marginBottom: '20px' }}>\n        <input\n          type=\"text\"\n          value={inputText}\n          onChange={(e) => setInputText(e.target.value)}\n          placeholder=\"新しいTodoを入力\"\n          style={{ flexGrow: 1, padding: '10px', marginRight: '10px' }}\n        />\n        <button type=\"submit\" style={{ padding: '10px' }}>追加</button>\n      </form>\n      <ul style={{ listStyle: 'none', padding: 0 }}>\n        {todos.map(todo => (\n          <li key={todo.id} style={{\n            display: 'flex', \n            alignItems: 'center', \n            marginBottom: '10px', \n            padding: '10px',\n            border: '1px solid #eee',\n            textDecoration: todo.completed ? 'line-through' : 'none'\n          }}>\n            <span onClick={() => toggleComplete(todo.id)} style={{ cursor: 'pointer', flexGrow: 1 }}>\n              {todo.text}\n            </span>\n            <button onClick={() => deleteTodo(todo.id)} style={{ marginLeft: '10px', background: 'red', color: 'white', border: 'none', padding: '5px 10px' }}>削除</button>\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n```\n\n**手順のポイント**:\n1.  APIルートはファイルシステムベースルーティングに従う。\n2.  APIハンドラ関数は `req` と `res` を受け取る。\n3.  フロントエンドから `fetch` API でエンドポイントにリクエスト送信。\n4.  状態管理は `useState`。APIレスポンスに基づきローカルTodoリスト更新。\n5.  エラーハンドリングと基本的な入力バリデーションをAPI側に追加。\n6.  社内API設計標準 (API-STD-001) があれば、それに準拠したエンドポイント設計、HTTPメソッド利用、ステータスコード返却、リクエスト/レスポンス形式、ヘッダ規約などを考慮する。",
      "timestamp": 1716196800000
    }
  ],
  "lastUpdated": 1716196800000,
  "isBookmarked": false,
  "isShared": false
}
